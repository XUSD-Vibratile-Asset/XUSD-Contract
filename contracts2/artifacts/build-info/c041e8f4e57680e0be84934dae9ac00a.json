{
	"id": "c041e8f4e57680e0be84934dae9ac00a",
	"_format": "hh-sol-build-info-1",
	"solcVersion": "0.8.26",
	"solcLongVersion": "0.8.26+commit.8a97fa7a",
	"input": {
		"language": "Solidity",
		"sources": {
			"contracts/LitPass.sol": {
				"content": "// // SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.24;\n\n// import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n// import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\n// import \"./registry.sol\";\n// import \"./atropamath.sol\";\n// import \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n// import \"./TUSDRegistry.sol\";\n\n\n//  import \"./ClassRegistry.sol\";\n\n\n//  interface IXUSD {\n//   function burnBalance(address user) external view returns (uint256);\n//   function totalBurned()external returns(uint);\n// }\n// contract LitPass is ERC721URIStorage, Ownable, TUSDRegistry {\n//   using LibRegistry for LibRegistry.Registry;\n\n//   using AtropaMath for address;\n\n\n//   ClassRegistry private access;\n\n//   error LitPassAlreadyMinted();\n//   error UserDoesNotOwnLitPassId();\n//   error LitPassDelegated();\n//   error LitPassCanOnlyHoldOne();\n//   error LitPassNonExistant();\n//   error LitPassNotDelegated();\n\n//   struct litpass {\n//     nfts litPass;    \n//     string uri;\n\n\n   \n   \n   \n//   }\n\n//   struct nfts {\n//     address owner;\n//     uint id;\n\n    \n//     uint ownerBurn;\n\n \n    \n//   }\n// struct KingList {\n//   address owner;\n//   uint burnAmount;\n//   string userName;\n//   uint tokenId;\n// }\n//   struct OwnerInfo {\n//     address owner;\n//     uint tokenId;  \n//     uint burnAmount;\n//     uint purchaseBurnAmount;\n//     uint accessKey;\n//     string url;\n//     uint bonus;\n//     uint totalInflation;\n//     uint totalBurn;\n//     string userName;\n//     uint aquired;\n//     string bio;\n//     mapping(uint => mapping(uint => string)) protocolMessages;\n//     mapping(uint => uint) messageIndex;\n    \n//   }\n\n\n//   LibRegistry.Registry private _LitPass;\n\n//   LibRegistry.Registry internal LitPassHolderReg;\n\n//   mapping(uint => string) internal protocolAlert;\n//   mapping(uint => mapping(uint => string)) internal protocolMessages;\n//   mapping(uint => string) internal uris;\n//   mapping(uint => OwnerInfo) internal LitPassHolder;\n  \n//   mapping(uint => nfts) internal NFTRegistry;\n//   mapping(address => bool) internal LitPassUserIndex;\n\n//   mapping(address => uint) internal LitPassTokenIdIndex;\n\n//   address public xusd;\n//   address public oneSwap;\n//   uint public purchaseAmount;\n\n//   constructor(\n//     address _oneSwap,\n//     address classReg\n//   ) public ERC721(\".\", \".\")  Ownable(msg.sender) {\n//     access = ClassRegistry(classReg);\n//     oneSwap = _oneSwap;\n   \n//   }\n\n//   function mintPass() public {\n//     uint newItemId = _LitPass.Count() + 1;\n//     uint hash = address(this).hashWithId(newItemId);\n  \n//    assert(access.HasAccess(msg.sender, AccessRegistry.AccessType.USER, address(this)));\n//     // uint hashU = address(this).hashWith(msg.sender);\n//     IERC20(oneSwap).transferFrom(msg.sender, address(this), purchaseAmount);\n//     if(!LitPassHolderReg.Contains(hash)){\n \n//     _safeMint(msg.sender, newItemId);\n//     // access.setLitPass(msg.sender, newItemId, address(this));\n//     //_setTokenURI(newItemId, uris[0]);\n//     setLit(msg.sender, newItemId, hash);\n//     }\n   \n  \n//  // else revert(\"no mint\");\n// }\n// function calculateTriHash(address user, uint number) public returns(uint) {\n//   uint h1 = address(this).hashWith(user);\n//   uint h2 = address(this).hashWith(user);\n//  // uint h3 = address(this).hashWith(from);\n// // (uint64 g, uint64 g2, uint64 g3) = AtropaMath.sortThree(uint64(h1), uint64(h2), uint64(h3));\n//   uint hash = AtropaMath.modExp64(uint64(h1), uint64(h2), uint64(number));\n//   // int addyBasis = IBase(class).claclBasis(addy, amount);\n//   return hash;\n// }\n\n//   function setXusd(address _xusd) external onlyOwner {\n//     xusd = _xusd;\n//   }\n\n//   function setRegistry(address registry) external onlyOwner {\n//     access = ClassRegistry(registry);\n//   }\n\n//   // function setKey(address user) external  {\n//   //  uint hashKey = address(AccessRegistry).hashWith(user);\n//   //  uint hash = address(this).hashWith(user);\n//   //  if(LitPassHolderReg.Contains(hash)){\n   \n//   //   LitPassHolder[hash].rank = AccessRegistry.accessors[hashKey].class;\n \n\n//   //  }\n\n//   // }\n\n//   function setPurchaseAmount(uint256 amount) external onlyOwner {\n   \n//     purchaseAmount = amount;\n//   }\n\n\n//   function transferFrom(\n//     address from,\n//     address to,\n//     uint tokenId\n//   ) public virtual override(ERC721, IERC721) {\n   \n\n//     setLitTransfer(from, to, tokenId);\n//     safeTransferFrom(from, to, tokenId);\n\n   \n//   }\n\n\n//   function setLitTransfer(address from, address to, uint id) internal {\n//     uint256 hashId = address(this).hashWithId(id);\n//     uint256 hashU = address(this).hashWith(from);\n//     uint256 hashT = address(this).hashWith(to);\n//     if(_LitPass.Contains(hashId)){\n\n\n\n//         if(!(LitPassHolder[hashU].owner == from)){    \n//             revert UserDoesNotOwnLitPassId();     \n//         } \n//         if(LitPassUserIndex[to]){\n//             revert LitPassCanOnlyHoldOne();\n//         } \n//         LitPassHolderReg.Remove(hashU);\n//         LitPassHolderReg.Register(hashT);\n//         NFTRegistry[hashId].owner = to;        \n//         LitPassHolder[hashT].tokenId = NFTRegistry[hashId].id;\n//         LitPassHolder[hashId].tokenId = 0;\n//         LitPassHolder[hashId].owner = address(0);\n//         LitPassHolder[hashT].tokenId = id;\n//         LitPassHolder[hashT].owner = to;\n//         LitPassTokenIdIndex[from] = 0; \n//         LitPassTokenIdIndex[to] = id; \n//         LitPassUserIndex[to] = true;\n//         LitPassUserIndex[from] = false;\n//     }\n//     else revert LitPassNonExistant();\n\n// }\n\n// function setLit(address user, uint id, uint hash) internal {\n//     uint256 hashId = address(this).hashWithId((id));\n\n\n  \n\n//         LitPassHolderReg.Register(hash);\n//         NFTRegistry[hashId].id = id;\n//         NFTRegistry[hashId].owner = user;\n//         LitPassHolder[hashId].purchaseBurnAmount = IXUSD(xusd).burnBalance(NFTRegistry[hashId].owner);\n//         NFTRegistry[hashId].ownerBurn = IXUSD(xusd).burnBalance(NFTRegistry[hashId].owner);\n//         LitPassHolder[hashId].tokenId = NFTRegistry[hashId].id;       \n//         LitPassTokenIdIndex[user] = id; \n//         LitPassHolder[hashId].url = uris[0];       \n//         LitPassUserIndex[user] = true;  \n\n// }\n\n  \n\n\n\n\n//   function hasLitPass(address user ) external  returns (bool) {\n \n\n\n//     return getOwner(getIdFromOwner(user)) == user;\n//   }\n\n//   function calculateRank()external {\n//     for(uint i; i < LitPassHolderReg.Count(); i++){\n\n//       getUserBurns(LitPassHolder[LitPassHolderReg.GetHashByIndex(i)].owner);\n\n//     }\n//     sort();\n  \n//   }\n\n//   function getUserList()external returns(KingList[] memory) {\n//     KingList[] memory kings = new KingList[](LitPassHolderReg.Count());\n//     for(uint i; i < LitPassHolderReg.Count(); i++){\n\n//       kings[i].owner =  LitPassHolder[LitPassHolderReg.GetHashByIndex(i)].owner;\n//       kings[i].burnAmount =  LitPassHolder[LitPassHolderReg.GetHashByIndex(i)].burnAmount;\n//       kings[i].tokenId =  LitPassHolder[LitPassHolderReg.GetHashByIndex(i)].tokenId;\n//       kings[i].userName =  LitPassHolder[LitPassHolderReg.GetHashByIndex(i)].userName;\n     \n\n//     }\n//   return kings;\n  \n//   }\n\n//   function getOwner(uint tokenId) public  returns (address) {\n//     uint256 hash = address(this).hashWithId(tokenId);\n \n//     return NFTRegistry[hash].owner;\n//   }\n\n//   function getIdFromOwner(address user) public view returns (uint) {\n   \n//     return LitPassTokenIdIndex[user];\n//   }\n\n//   function getUserBurns(address user) public {\n//     uint256 hash = address(this).hashWith(user);\n//     LitPassHolder[hash].burnAmount =  IXUSD(xusd).burnBalance(LitPassHolder[hash].owner) -  LitPassHolder[hash].purchaseBurnAmount;\n//   }\n\n//     function sort() public   {\n//       uint256 length = LitPassHolderReg.Count();\n\n//       // Bubble Sort algorithm\n//       for (uint256 i = 0; i < length; i++) {\n//           for (uint256 j = 0; j < length - i - 1; j++) {\n//               if (LitPassHolder[LitPassHolderReg.GetHashByIndex(j)].burnAmount > LitPassHolder[LitPassHolderReg.GetHashByIndex(j + 1)].burnAmount) {\n//                   // Swap elements\n//                   uint256 temp = LitPassHolder[LitPassHolderReg.GetHashByIndex(j)].burnAmount;\n//                   LitPassHolder[LitPassHolderReg.GetHashByIndex(j)].burnAmount = LitPassHolder[LitPassHolderReg.GetHashByIndex(j+1)].burnAmount;\n//                   LitPassHolder[LitPassHolderReg.GetHashByIndex(j+1)].burnAmount = temp;\n//               }\n//           }\n//       }\n\n      \n//   }\n\n//   function calculateBurn(address user) public  returns (uint) {\n//     uint256 hash = address(this).hashWith(user);\n//    // uint256 userHash = address(this).hashWith(NFTRegistry[hash].owner);\n//     NFTRegistry[hash].ownerBurn = IXUSD(xusd).burnBalance(NFTRegistry[hash].owner);\n   \n//     return IXUSD(xusd).burnBalance(NFTRegistry[hash].owner);\n//   }\n\n//   function getProtocolBurn(address user) public   {\n//     uint256 hash = address(this).hashWith(user);\n//    // uint256 userHash = address(this).hashWith(NFTRegistry[hash].owner);\n//    LitPassHolder[hash].totalBurn = IXUSD(xusd).totalBurned();\n\n//   }\n\n//   function setUserName(address user, string memory userName) public   {\n//     uint256 hash = address(this).hashWith(user);\n \n//    LitPassHolder[hash].userName = userName;\n\n//   }\n\n//   function viewUserName(address user) public view returns(string memory)   {\n//     uint256 hash = address(this).hashWith(user);\n \n//    return LitPassHolder[hash].userName;\n\n//   }\n\n//   function viewUserBurns(address user) public view returns(uint)   {\n//     uint256 hash = address(this).hashWith(user);\n \n//    return LitPassHolder[hash].burnAmount;\n\n//   }\n\n\n//   function viewTotalBurn(address user) public view returns(uint)   {\n//     uint256 hash = address(this).hashWith(user);\n \n//    return LitPassHolder[hash].totalBurn;\n\n//   }\n\n//   function viewUrl(address user) public view returns(string memory)   {\n//     uint256 hash = address(this).hashWith(user);\n \n//    return LitPassHolder[hash].url;\n\n//   }\n\n\n\n\n// function GetNftByIndexHash(uint256 i) public view returns (uint) {\n//     uint256 hash = _LitPass.GetHashByIndex(i);       \n//     return hash;\n// }\n\n// // function turnOnDelegate(uint tokenId) public  {\n// //   uint256 hash = address(this).hashWithId(tokenId);   \n// //   if(!(NFTRegistry[hash].owner == msg.sender)) revert(\"not owner\");\n// //   setDel(tokenId);\n\n \n// // }\n\n// // function turnOffDelegate(uint tokenId) public  returns (uint) {\n// //   uint256 hash = address(this).hashWithId(tokenId);   \n// //   if(!(NFTRegistry[hash].owner == msg.sender)) revert(\"not owner\");\n// //   removeDel(tokenId);\n\n// // }\n\n// // function setDel(uint tokenId)internal {\n// //   uint256 hash = address(this).hashWithId(tokenId); \n// //   DelegatePoolReg.Register(hash);\n\n// // }\n\n// // function removeDel(uint tokenId)internal {\n// //   uint256 hash = address(this).hashWithId(tokenId); \n// //   DelegatePoolReg.Remove(hash);\n\n// // }\n//   /**\n//    * @notice Gets the total count of registered classes.\n//    * @return The total count of registered classes.\n//    */\n\n\n// //   function ProposedClassRegistryCount() public view returns (uint256) {\n// //     return ProposedClasses.Count();\n// //   }\n\n//   // function GetClassByIndex(uint256 i) public view returns (Class memory) {\n//   //     uint256 hash = ClassRegistryList.GetHashByIndex(i);\n//   //     return Classes[hash];\n//   // }\n\n//   // function GetProspectClassByIndex(uint256 i) public view returns (ProposedClass memory) {\n//   //     uint256 hash = ProposedClasses.GetHashByIndex(i);\n//   //     return ProspectClass[hash];\n//   // }\n\n//   // function ProposeClass(address dom) public  {\n//   //    // require(HasAccess(msg.sender, AccessType.CONGRESS), NotAllowedAccess());\n//   // require(HasAccess(msg.sender, AccessType.CONGRESS), \"You dont have access to propose a new class\");\n//   // uint256 hash = address(this).hashWith(dom);\n//   // IClassBase(dom).getClassBasis();\n//   // IClassBase(dom).getActiveAdd(owner(), address(0), address(0), address(0), 0x23b872dd, 0);\n//   // IClassBase(dom).getActiveSub(owner(), address(0), address(0), address(0), 0x23b872dd, 0);\n\n//   // if(ProposedClasses.Contains(hash)){\n//   //     revert AlreadyProposed();\n//   // }\n//   // ProspectClass[hash].classAddress = dom;\n//   // ProspectClass[hash].votes = 0;\n//   // ProposedClasses.Register(hash);\n\n//   // }\n\n//   // function VoteClass(address dom) public  {\n//   //     require(HasAccess(msg.sender, AccessType.USER), \"You dont have access to propose a new class\");\n//   //     require(ClassProposedValid(dom), \"Not up for vote\");\n\n//   //     uint256 hash = address(this).hashWith(dom);\n\n//   //     ProspectClass[hash].votes += accessValues[Accessors[hash].Class];\n\n//   //     }\n\n//   // function SetClass(address dom) internal {\n//   //     uint256 hash = address(this).hashWith(dom);\n//   //     if(ClassRegistryList.Contains(hash)) {\n\n//   //     }\n//   //     if(HasAccess(msg.sender, AccessType.CONGRESS)) {\n//   //         ClassRegistryList.Register(hash);\n//   //         Classes[hash].classAddress = dom;\n//   //         Classes[hash].basisFee = IClassBase(dom).getClassBasis();\n\n//   //     } else {\n//   //         assert(ProspectClass[hash].PassedVote(AccessRegistryCount()));\n\n//   //         delete ProspectClass[hash];\n//   //         ProposedClasses.Remove(hash);\n//   //         ClassRegistryList.Register(hash);\n//   //         Classes[hash].classAddress = dom;\n//   //         Classes[hash].basisFee = IClassBase(dom).getClassBasis();\n\n//   //     }\n//   // }\n\n//   // /**\n//   //  * @notice Removes a class from the registry.\n//   //  * @param dom The address of the class.\n//   //  */\n//   // function RemoveClass(address dom) internal {\n//   //     uint256 hash = address(this).hashWith(dom);\n//   //     ClassRegistryList.Remove(hash);\n//   //     delete Classes[hash];\n\n//   // }\n// }\n"
			}
		},
		"settings": {
			"optimizer": {
				"enabled": true,
				"runs": 100
			},
			"outputSelection": {
				"*": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"metadata",
						"devdoc",
						"userdoc",
						"storageLayout",
						"evm.legacyAssembly",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"evm.gasEstimates",
						"evm.assembly"
					]
				}
			},
			"remappings": []
		}
	},
	"output": {
		"errors": [
			{
				"component": "general",
				"errorCode": "3420",
				"formattedMessage": "Warning: Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.8.26;\"\n--> contracts/LitPass.sol\n\n",
				"message": "Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.8.26;\"",
				"severity": "warning",
				"sourceLocation": {
					"end": -1,
					"file": "contracts/LitPass.sol",
					"start": -1
				},
				"type": "Warning"
			}
		],
		"sources": {
			"contracts/LitPass.sol": {
				"ast": {
					"absolutePath": "contracts/LitPass.sol",
					"exportedSymbols": {},
					"id": 1,
					"license": "MIT",
					"nodeType": "SourceUnit",
					"nodes": [],
					"src": "13995:0:0"
				},
				"id": 0
			}
		}
	}
}